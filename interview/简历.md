# Vue基础部分
## 1.Vue的 nextTick 原理
答:
1. nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。
2. 在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。
+ href：'./vue/1.Vue的 nextTick 原理.html'

## 2.Vue的生命周期？
答：
1. 创建前(beforeCreate)：实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据。
2. 创建后(create)：实例创建完成，可访问data、computed、watch、methods上的方法和数据、未挂载到DOM上、不能访问到$el属性、$ref属性内容为空数组。
3. 挂载前(beforeMount)：在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数，beforeMount 就是在挂载前执行的，然后开始创建 VDOM 并替换成真实 DOM，最后执行。
4. 挂载后(mounted)：实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问。
5. 更新前(beforeUpdate)：响应式数据更新时调用，发生在虚拟DOM打补丁之前。
6. 更新后(updated)：虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作
7. 销毁前(beforeDestroy)：实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例。
8. 销毁后(destoryed)：实例销毁后调用，调用后，vue实例指示的所有东西会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
+ <-注意->：
created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。

+ <-单个组件的生命周期->：
    1. 初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数
    2. 当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数
    3. 当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数
    4. 初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行

+ href：'./vue/2.vue的生命周期.html'

## 3.v-model的原理？
答：
+ 官方文档中对v-model的描写仅仅是一个语法糖。
1. 先靠v-bind：绑定响应式数据
2. 触发v-on：input事件
+ href：'./vue/3.v-model的原理.html'

## 4.watch和computed的区别和运用的场景
答：
1. 前端是计算属性，依赖其他属性计算值。并且computer的值有缓存，只有当计算值变化才变化触发渲染。后者监听值的变化就会执行回调。
2. computer就是简单的计算一下，适用于渲染页面。watch适合做一些复杂的业务逻辑。
3. 前者有依赖两个watcher，computer watcher 和渲染watcher。判断计算出的值变化后渲染watcher派发更新触发渲染。
+ 业务差异：
    1. computed是计算一个新的属性，并将该属性挂载到vm（Vue实例）上，而watch是监听已经存在且已挂载到vm上的数据，所以用watch同样可以监听computed计算属性的变化（其它还有data、props）
    2. computed本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而watch则是当数据发生变化便会调用执行函数
    3. 从使用场景上说，computed适用一个数据被多个数据影响，而watch适用一个数据影响多个数据；

## 5.Vue的响应系统核心？
答：
1. observe:遍历data中的属性，使用 Object.defineProperty 的get/set方法对其进行数据劫持
2. dep：每个属性拥有自己的消息订阅器dep，用于存放所有订阅了该属性的观察者对象
3. watcher：观察者（对象），通过dep实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应

## 6.Vue父子之间的通信？
答：
1. 使用v-model实现父传子，子传父。因为v-model默认解析成:value和:input
2. 父传子：
    1. 通过props
    2. 通过$children 访问子组件数组，注意该数组乱序
    3. 对于多级父传子，可以使用v-bind={$attrs},通过对象的方式筛选出父组件中传入子组件不需要的props
    4. $listens包含了父作用域中的(不含 .native修饰器的) v-on 事件监听器
2. 子传父
    1. 父组件传递函数给子组件，子组件通过$emit触发
    2. 修改父组件的props
    3. 通过$parent访问父组件
    4. .sync
3. 兄弟(平行)组件
    1. EventBus
4. Vuex 解决一切

## 7.路由原理？
答：
+ 前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式
  1. hash模式
  2. history模式

+ hash模式：www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面。

+ History模式:是 HTML5 新推出的功能，比之 Hash URL 更加美观

## 8.自我封装一个vue-router？

## 9.Vue数据劫持？
答：
+ href:'@/EmploymentClass/数据双向绑定/数据劫持.html'

## 10.什么是MVC？什么是MVVM？
答：

 + __MVC的定义__：是Model-View-Controller的简写。即模型-视图-控制器。M和V指的意思跟MVVM中的M和V的意思一样。C即是Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。

 + __MVVM的定义__:是Mode-View-ViewModel的简写。即模型-视图-视图模型。【视图模型】是MVVM模式的核心，它是链接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：实属绑定。而是将【视图】转化成【模型】,即将所看到的页面转化为后端的数据。实现的方式是：DOM事件监听。这两个方向都实现的，我们称之为数据双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的变化，然后通知到对应的视图走自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上实现了数据的双向绑定。并且MVVM中的View和ViewModel可以互相通信。

 + __MVVM总结__：
 在JQuery时期，如果需要刷新UI时，需要先取到的DOM再更新UI，这样数据和业务的逻辑就和页面有强耦合。
 在MVVM中，UI是通过数据驱动的，数据一旦改变就会相应的刷新对应的UI，UI如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel只关心数据和业务的处理，不关心View如何处理数据，在这种情况下，View和Model都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可服用的逻辑放在一个ViewModel中，让多个View复用这个ViewModel。

 + 在MVVM中，最核心的业就是数据双向绑定，例如Angluar的脏数据监测，Vue中的数据劫持。
   1. 脏数据检测：当触发了指定事件后会进入脏数据检测，这时会调用$digest循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用$watch函数，然后再次调用$digest循环直到发现没有变化。循环至少为2次，至多为10次。
   脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在Vue中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新UI，大大减少了操作DOM的次数。所以低效也是相对的，这就仁者见仁智者见智了。

   2. 数据劫持：Vue内部使用了Object.definePropery()来实现双向绑定，通过这个函数可以监听到set和get的事件。href:'@/EmploymentClass/数据双向绑定/数据劫持.html'  
   > url：‘https://juejin.im/post/5ba34e54e51d450e5162789b#heading-68’
 
 + href:'@/深入vue源码/重写getter，setter源码实现MVVM原理/index.html'

 ## 11.Proxy与Object.defineProperty对比

 + Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
   1. 只能对属性进行数据劫持，所以需要深度遍历整个对象。
   2. 对于数组不能监听到数据的变化。
   3. 数组的方法也是在原型上二次添加进去的

+ 反观Proxy就没以上的问题，原生支持监听数组的变化，并且可以直接对整个对象进行拦截，所以Vue也将在下个大版本中使用Proxy替换Object.defineProperty

## 12.什么是虚拟DOM？为什么需要虚拟DOM？算法的实现？
答:
1.  众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多。
2.  不需要数据双向绑定修改后刷新所有的dom，修改哪里就只干涉那一小部分。
3.  还有个重要一点实虚拟dom可以跨平台：
4. 虚拟 DOM 是 DOM 在内存中的一种轻量级表达方式，是一种统一约定！可以通过不同的渲染引擎生成不同平台下的 UI！
5. 虚拟 DOM 的可移植性非常好，这意味着可以渲染到 DOM 以外的任何端


+ 总结一下虚拟DOM算法：
  1. 通过JS来模拟创建DOM对象
  2. 判断两个对象的差异 
  3. 渲染差异

+ 总结：可维护性、最小的代价、效率、函数式UI、数据驱动

+ href:'https://juejin.im/post/5b10dd36e51d4506e04cf802'

## 13.什么是路由鉴权（指验证用户是否拥有访问系统的权利）
答：
1. 登录页和其他页面分开，登录以后实例化Vue并且初始化需要的路由
2. 动态路由，通过addRoute实现

## 14.请谈谈Vue和React的区别？
1. React是单向数据流，Vue双向数据绑定（更好进行表单验证）。
2. 改变数据方式不同，setState有使用坑。
3. props Vue可变（但是会发出警告），React不可变
4. 判断是否需要更新React可以通过钩子函数判断，Vue使用依赖追踪，修改了什么菜渲染什么
5. React 16版本以后 有些钩子函数会执行多次
6. React需要使用JSX，需要Babel编译。Vue虽然可以使用模板，但是也可以通过直接编写render函数不需要编译就能运行。
7. React的思路是all in js（万物都可js），通过js生成html所以设计了jsx，可以用js来操作css。Vue则是把html，css，js写到一个文件中，用各自处理的方式。html提供了模板引擎来处理。
8. React的组件是es6类的写法。Vue是生命式的写法，通过传入各种options，api和参数都很多。所以React更容易和TS结合，而Vue稍微复杂。

+ 而这两点的区别，其实也是因为 React 和 Vue的设计理念上的区别。React更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用React，小型项目用 Vue的感觉。

## 15.你知道vue3.0更新后的改变吗？
答：
1. Virtual DOM（虚拟DOM）完全重写，大大优化。
2. 增多一些编译提醒 来介绍运行的成本。
3. 废除Object.definedProperty来监听数据变动，改用原生ES6中的Proxy观察机制。
4. 组件生成增快100%
5. 速度快一倍/减少一半的内存使用
6. 新的 runtime 版只要约 10kb gzipped
7. 自定义的renderer API
8. 更好的拥抱TS（因为本身就是用TS重写Vue3），因为可以像写React类组件的方式书写Vue。

## 16.第一次页面加载会触发哪几个钩子？
答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。


## 17.vue中key值的作用？
答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。

## 18.vue中计算属性computed的优势？
答：
1. 使得数据处理结构清晰；
2. 依赖于数据，数据更新，处理结果自动更新；
3. 计算属性内部this指向vm实例；
4. 在template调用时，直接写计算属性名即可；
5. 相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。

## 19.vue等单页面应用及其优缺点？
答：
+ 优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
+ 缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

## 20.vuex是什么？
答：Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交mutation。

## 21.Vuex解决了什么问题？
答：
1. 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。
2. 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

## 22.什么时候用Vuex？
答：
1. 多个组件依赖于同一状态时。
2. 来自不同组件的行为需要变更同一状态。

## 23.Vuex的5个核心属性是什么？
答：分别是 state、getters、mutations、actions、modules 。

## 24.Vuex中状态储存在哪里，怎么改变它？
答：存储在state中，改变Vuex中的状态的唯一途径就是显式地提交 (commit) mutation。

## 25.Vuex中状态是对象时，使用时要注意什么？
答：因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。

## 26.怎么在组件中批量使用Vuex的state、getter、mutation、action？
答：
+ 使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中。
+ 使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中。
+ 使用mapMutations辅助函数,在组件中这么使用
+ 使用mapActions辅助函数,在组件中这么使用
```javascript
    import {mapState} from 'vuex'
    export default{
        computed:{
            ...mapState(['price','number'])
        }
    }
```
```javascript
    import {mapGetters} from 'vuex'
    export default{
        computed:{
            ...mapGetters({
                myTotal:'total',
                myDiscountTotal:'discountTotal',
            })
        }
    }
```
```javascript
    import { mapMutations } from 'vuex'
    methods:{
        ...mapMutations({
            setNumber:'SET_NUMBER',
        })
    }
    this.setNumber(10)
```
```javascript
    methods:{
        ...mapActions({
            setNumber:'SET_NUMBER',
        })
    }
    //然后调用this.setNumber(10)相当调用this.$store.dispatch('SET_NUMBER',10)
```
## 27.Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做，？
答：
1. 使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。
```javascript
    const store = new Vuex.Store({
    state: {
        price: 10,
        number: 10,
        discount: 0.7,
    },
    getters: {
        total: state => {
            return state.price * state.number
        },
        discountTotal: (state, getters) => {
            return state.discount * getters.total
        }
    },
});
```
2. 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。
```javascript
    computed: {
    total() {
        return this.$store.getters.total
    },
    discountTotal() {
        return this.$store.getters.discountTotal
    }
}
```
## 28.在Vuex中使用mutation要注意什么。
答：mutation 必须是同步函数

## 29.Vuex中action和mutation有什么区别？
答：
1. action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。
2. action 可以包含任意异步操作。mutation只能是同步操作。
3. 提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。mutation是用this.$store.commit('SET_NUMBER',10)来提交。
4. 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了

## 30.Vuex中action和mutation有什么相同点？
答：第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch('ACTION_NAME',data)和this.$store.commit('SET_NUMBER',10)

## 31.Vuex中action通常是异步的，那么如何知道action什么时候结束呢？
答：
+ 在action函数中返回Promise，然后再提交时候用then处理
```javascript
    actions:{
        SET_NUMBER_A({commit},data){
            return new Promise((resolve,reject) =>{
                setTimeout(() =>{
                    commit('SET_NUMBER',10);
                    resolve();
                },2000)
            })
        }
    }
    this.$store.dispatch('SET_NUMBER_A').then(() => {
    // ...
})
```

## 32.有用过Vuex模块吗，为什么要使用，怎么使用？
答：
+ 有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。
在module文件新建moduleA.js和moduleB.js文件。在文件中写入
```javascript
    const state={
        //...
    }
    const getters={
        //...
    }
    const mutations={
        //...
    }
    const actions={
        //...
    }
    export default{
        state,
        getters,
        mutations,
        actions
    }
```
然后再index.js引入模块
```javascript
    import Vue from 'vue';
    import Vuex from 'vuex';
    Vue.use(Vuex);
    import moduleA from './module/moduleA'
    import moduleB from './module/moduleB'
    const store = new Vuex.Store({
        modules:{
            moduleA,
            moduleB
        }
    })
    export default store
```

## 33. 在模块中，getter和mutation和action中怎么访问全局的state和getter？
答：
1. 在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。
2. 在mutation中不可以访问全局的satat和getter，只能访问到局部的state。
3. 在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。

## 34.在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？
答：
1. 直接通过this.$store.getters和this.$store.state来访问模块中的getter和state。
2. 直接通过this.$store.commit('mutationA',data)提交模块中的mutation。
3. 直接通过this.$store.dispatch('actionA,data')提交模块中的action。

## 35.在Vuex插件中怎么监听组件中提交mutation和action？
答：
1. 用Vuex.Store的实例方法subscribe监听组件中提交mutation
2. 用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入

```javascript
export default function createPlugin(param) {
    return store => {
        store.subscribe((mutation, state) => {
            console.log(mutation.type)//是那个mutation
            console.log(mutation.payload)
            console.log(state)
        })
        // store.subscribeAction((action, state) => {
        //     console.log(action.type)//是那个action
        //     console.log(action.payload)//提交action的参数
        // })
        store.subscribeAction({
            before: (action, state) => {//提交action之前
                console.log(`before action ${action.type}`)
            },
            after: (action, state) => {//提交action之后
                console.log(`after action ${action.type}`)
            }
        })
    }
}
```
然后在store/index.js文件中写入
```javascript
    import createPlugin from './plugin.js'
    const myPlugin = createPlugin()
    const store = new Vuex.Store({
    // ...
    plugins: [myPlugin]
    })
```
## 36.在v-model上怎么用Vuex中state的值？
答：需要通过computed计算属性来转换。
```javascript
   <input v-model="message">
    computed: {
        message: {
            get () {
                return this.$store.state.message
            },
            set (value) {
                this.$store.commit('updateMessage', value)
            }
        }
    }
```
https://juejin.im/post/5d9c43b751882507b40d3376